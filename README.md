# 한입 크기로 잘라 먹는 리액트 실습 따라하기 (1)

# 간단한 일기장 프로젝트

git clone url
git pull

# React 컴포넌트의 생애 주기(생명주기)

- 탄생 : 화면에 나타나는 순간(Mount)

  - ComponentDidMount => 컴포넌트가 마운트 되는 순간에 어떤걸 수행할수 있는 함수

- 변화 : 업데이트(리렌더\_Update)
  state가 바뀌거나 부모가 리렌더 되거나 prop이 바뀌어서 컴포넌트 자신이 리렌더 되는과정을 변화라고 표현

  - ComponentDidUpdate => 컴포넌트가 변화 하는 순간에 사용

- 죽음 : 컴포넌트가 화면에서 사라지는것(UnMount)
  - ComponentWillUnmount => 컴포넌트가 언마운트 되기전에 호출해서 사용

# React Hooks

- 함수형 컴포넌트에서 클래스형 컴포넌트의 기능을 훔쳐와서 사용할수 있도록 도와주는 기능
- 중복 코드, 가독성 문제 등등을 해결하기 위해 등장함.

# useMemo

- 리액트에서 이렇게 return을 가지고 있는 함수를 메모이제이션 해서 이런 연산을 최적화 하기위해 useMemo를 사용한다.
- 우리가 최적화 하고 싶은 메모이제이션함수를 감싸주면된다.
- useMemo함수를 반환하는게 아니라 값을 반환한다.

- useMemo에서 자주하는 실수
  - useMemo를 사용하게 되면 더이상 함수가 아니게 된다.
  - 왜냐하면 useMemo라는 기능은 어떤 함수를 전달을 받아서 무엇을 리턴하는가? => callback함수가 리턴하는 값을 그냥 리턴하기 때문에

# React.memo(OptimizeTest.js컴포넌트 참고)

- React.memo 기능 => 함수형 컴포넌트에게 업데이트 조건을 걸자
- React.memo는 고차 컴포넌트( HOC, Higher Order Component ) -> 고차 컴포넌트는 컴포넌트를 가져와 새 컴포넌트를 반환하는 함수
- React.memo는 동일한 props로 동일한 결과를 렌더링한다면 결과를 메모이징하고, 렌더링하지 않고 마지막으로 렌더링된 결과를
  재사용(= 똑같은 prop을 받으면 똑같은걸 내놓겠다, 똑같은 prop을 바뀐것처럼 줘도 똑같잖아 하고 계산X(리렌더X))
- React.memo의 비교대상이 객체인 경우 메모리 주소가 다르기 때문에 값이 같다고 다르다고 인지하여 리렌더 시키는 경우가 있음
- -> 이경우에 areEqual를 사용하여 자세히 객체 값을 비교해 준다. true를 반환할 경우 리렌더링X, false를 반환하는 경우 리렌더링O

# useCallback

- 메ㅁ이제이션 된 홀캘함수를 반환 한다.
- 사용 하기 전 어떤 컴포넌트가 최적화 대상인지 먼저 찾아야함
  -> 리액트 디벨로퍼 툴스 이용하기(디벨로퍼 툴즈 하이라이트 업데이트 웹 컴포넌트 기능 체크 박스를 켜주면 리렌더링이 일어나는 컴포넌트를 쉽게 확인이 가능하다.)
